### 第一章 为什么要有RISC-V？

1.1 RISC-V的目标是成为一个通用的指令集架构（ISA就是指令集架构的意思）。

​        指令集架构不仅仅是一组指令的集合，它还要定义任何软件程序员需要了解的硬件信息，包括：数据类型、存储模型、软件可见的处理器状态、指令集、系统模型和外部接口。

1.2 模块化与增量型ISA

​        计算机体系结构的传统方法是增量ISA，新处理器不仅必须实现新的ISA扩展，还必须实现过去的所有扩展。

   （作为一个类比，假设一家餐馆只提供固定价格的餐点，最初只是一顿包含汉堡和奶昔
的小餐。随着时间的推移，它会加入薯条，然后是冰淇淋圣代，然后是沙拉，馅饼，葡萄
酒，素食意大利面，牛排，啤酒，无穷无尽，直到它成为一顿大餐。食客可以在那家餐厅
找到他们过去吃过的东西，尽管总的来说这样做可能没什么意义。这样做的坏处是，用餐
者为每次晚餐支付的宴会费用不断增加。）

​        RISC-V的不同寻常之处，除了在于它是最近诞生的和开源的以外，还在于：和几乎所有以往的ISA不同，它是模块化的。模块化来源于可选的标准扩展，根据应用程序的需要，硬件可以包含或不包含这些扩展。模块化特性使得RISC-V具有了袖珍化、低能耗的特点。

1.3 ISA设计的基本原则与权衡

七种衡量标准

1. 成本

​    处理器通过集成电路实现，芯片或晶粒。ISA简洁，从而缩小ISA处理器的尺寸。

   2.简洁性

​    ISA简洁，从而缩小ISA处理器的尺寸。RISC-V ISA 比 ARM-32 ISA 简洁得多。

   3.性能

​    性能主要指的是执行一个程序所需要的时间。

   4.架构和具体实现的分离

​    机器语言程序员了解架构后能写出正确的程序，却不一定能保证性能。

   5.提升空间（保留疑问？）

​    如今的ISA 必须保留操作码空间以供未来的提升。

   6.程序大小

​    程序越小，存储它所需的芯片面积就越小(这对于嵌入式设备来说可能是一个巨大的成本)。更小的程序还能减少指令缓存的未命中问题，从而节省了功耗（因为片外 DRAM访问比片上 SRAM 访问耗能更多），也提高了性能。短的代码长度是 ISA 架构师的目标之一。

  7.易于编程/编译/链接

​    ARM-32 有 16 个寄存器，而 x86-32 只有 8 个。大多数现代 ISA（包括 RISC-V）都有 32 个整型寄存器。

​    一般每条 RISC-V 指令最多用一个时钟周期执行（忽略缓存未命中）。但正如我们之前看到的，ARM-32 和 x86-32 都有需要很多个时钟周期执行（即使所有缓存都命中）的指令。此外，与 ARM-32 和 RISC-V 不同，x86-32 的算术指令操作数可以在存储器中，而不必都在寄存器里。

### **第二章** **RV32I：**RISC-V **基础整数指令集**

1.  寄存器

 32个x寄存器，RV32下x reg是32位宽

 x0：硬连线 常数0

 x1-x31：31个通用reg

 返回地址：没有强制要求那一个x作为lr，但是一般用x1

 pc：额外的用户可见寄存器



3. 基本指令格式

 四种基础指令格式 R/I/S/U

 imm：立即数

 rs1：源寄存器1

 rs2：源寄存器2

 rd：目标寄存器

 opcode：操作码

 

4. 立即数

 各种指令格式下，拼装出立即数

 inst[i]：指令第i位

 

5. 整数计算

 使用R或者I类指令

 R类：寄存器-立即数

 I类：寄存器-寄存器

 整数计算不会造成运算异常

 

 寄存器-立即数:

 ADDI：将12位有符号立即数和rs相加，溢出忽略，直接使用结果的最低32bit，并存入rd

 伪指令MV："MV rd,rs"实际上是"ADDI rd, rs, 0"

 SLTI：如果rs小于立即数(都是有符号整数),将rd置1,否则置0

 SLTIU：和SLTI一致，不过都是无符号数

 伪指令SEQZ："SEQZ rd, rs" 实际上是 "SLTIU rd, rs1, 1"

 ANDI/ORI/XORI：rs与有符号12位立即数进行and,or,xor操作

 伪指令NOT："NOT rd, rs"实际上是"XORI rd, rs1, -1"

 

 shift是I类指令格式

 SLLI：逻辑左移，低位移入0

 SRLI：逻辑右移，高位移入0

 SRAI：算数右移，符号移入高位

 

 u类指令格式

 LUI：创建32位无符号整数，存放立即数到rd的高20位，低20位置0

 AUIPC：创建pc的相对地址，pc+无符号立即数(偏移量)=>rd 

 

 寄存器-寄存器:

 ADD/SUB:rs1(+/-)rs2 => rd

 SLT/SLTU: 如果rs1<rs2，rd写1; 否则rd为0

 AND/OR/XOR: rs1与rs2进行and,or,xor操作

 SLL/SRL/SRA: 和"寄存器-立即数"指令一致，将r2的低5位作为立即数即可 

 

 NOP指令:

 实际上是ADDI x0,x0,0

 

6. 控制传输指令

 1）非条件跳转: 

 JAL：J类指令，立即数+pc为跳转目标，rd存放pc+4（返回地址）

 跳转范围为pc(+/-)1MB

 JALR：I类指令，rs+立即数为跳转目标，rd存放pc+4（返回地址）

 实现远跳转

 

 2）条件跳转

 所有分支指令使用B类指令格式，12位立即数+pc作为目标

 跳转范围为pc(+/-)4KB

 

 BEQ/BNE：rs1(==/!=)rs2, 分别在相等或者不等时，发生跳转

 BLT：rs1 < rs2, 跳转

 BGE：rs1 >= rs2, 跳转

 

7. 加载存储指令

 RV32I是一个加载/存储架构，只有load/store能访问内存，运算指令只操作寄存器

 load是I类指令，store是S类指令

 

 LOAD：rs作为基地址，加上有符号的偏移，读取到rd寄存器

 STORE：rs1作为基地址加上有符号的偏移，作为内存地址，写入内容为rs2

 

8. 内存模型

 RISC-V ISA支持单地址空间上多线程运行，每个hardware thread都有都有自己的寄存器状态

 

9. 控制状态寄存器指令

 寄存器-寄存器：读/写/修改 CSR

 CSRRW：Atomic Read/Write CSR

 读取CSR的值存入rd寄存器，并将rs存入CSR

 另外：如果rd为x0,将不会执行 

 

 CSRRS：Atomic Read and Set Bits in CSR

 读取CSR的值存入rd寄存器，并根据rs中高位对CSR置1

 另外：如果rs为x0,将不会执行

 CSRRC：Atomic Read and Clear Bits in CSR

 读取CSR的值存入rd寄存器，并根据rs中高位对CSR置0

 另外：如果rs为x0,将不会执行 



 立即数-寄存器：读/写/修改 CSR

 CSRRWI/CSRRSI/CSRRCI

 将CSRRW类寄存器中的rs换成立即数

 另外：如果立即数为0,将不会执行 



 用户级系统指令：时钟和计数器

 RV32I提供三个64位只读用户级寄存器：RDCYCLE[H]/RDTIME[H]/RDINSTRET[H]

 使用CSRRS读取这三个寄存器的高32 bit

 RDCYCLE：时钟周期计数

 RDTIME：时间 tick数

 RDINSTRET：指令数

 

10. 环境调用和断点

 ECALL

 EBREAK

引用：(https://blog.csdn.net/zhangshuaiisme/article/details/80718496)



2.1

下图是RV32I基础指令集得一页图形表示：

![image-20201206191841652](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20201206191841652.png)

将有下划线的字母从左到右连接起来，即可组成完整的RV32I指令集。

如图中的slt就是一个指令，还有slti、sltu、sltiu三条指令。



2.2 RV32I指令格式：

![image-20201206192227573](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20201206192227573.png)

这里有6种基本指令格式：

1、用于寄存器-寄存器操作的 R 类型指令；（这里与上述引用的笔记不同，我觉得还是应该以这里为准）

2、用于短立即数和访存 load 操作的 I 型指令；

3、用于访存 store 操作的 S 型指令；

4、用于条件跳转操作的 B 类型指令；

5、用于长立即数的 U 型指令；

6、用于无条件跳转的 J 型指令；

**疑惑1：**立即数是什么？（**立即数就是写在指令里的常数**）用函数举例子，函数语句 y = f(x,12)，那么这个 12 就在函数语句里，而 x 是未知数。那么 12 相当于指令里的立即数。

补充说明：B 类型和 J 类型指令

如下所述，分支指令（B 类型）的立即数字段在 S 类型的基础上旋转了 1 位。跳转指令（J类型）的直接字段在 U 类型的基础上旋转了 12 位。因此,RISC-V 实际上只有四种基本格式，但我们可以保守地认为它有六种格式。

**疑惑2：**上述中的“旋转”是什么意思？（暂未找到解答……）



2.3 RV32I寄存器

RV32I 有 31 寄存器加上一个值恒为 0 的x0寄存器。与之相比，ARM-32 只有 16 个寄存器，x86-32 甚至只有 8 个寄存器。

**为常量 0 单独分配一个寄存器是 RISC-V ISA 能如此简单的一个很大的因素。**

（读到第3章，可能就明白为什么了）



2.4 RV32I整数计算

1、RISC-V 中没有字节或半字宽度的整数计算操作。操作始终是以完整的寄存器宽度。

2、RV32I 也不包含乘法和除法。



2.5  RV32I 的Load 和 Store

1、RV32I 支持加载有符号和无符号字节和半字（lb，lbu，lh，lhu）和存储字节和半字（sb，sh）

2、RV32I 省略了 ARM-32 和 x86-32 的复杂寻址模式，RV32I 寻址不会歧视任何数据类型。

3、ARM-32 和 MIPS-32 要求存储在内存中的数据，要按照数据的自然大小进行边界对齐，但是 RISC-V 没有这个要求。



2.6 RV32I 条件分支

1、RV32I 可以比较两个寄存器并根据比较结果上进行分支跳转。

相等（beq），不相等 （bne），大于等于（bge），或小于（blt）。最后两种比较有符号比较，RV32I 也提供相应的无符号版本比较的：bgeu 和 bltu。



2.7 RV32I 无条件跳转

不同之处：RV32I 避开了错综复杂的程序调用指令，例如 x86-32 的进入和离开指令，或 Intel Itanium，Oracle SPARC 和 Cadence Tensilica 中的寄存器窗口。

（这里没有很理解……）



2.8 RV32I 杂项

不同之处：RISC-V 使用内存映射 I / O 而不是像 x86-32 一样，使用 in，ins，insb，insw 和 out，out，outsb 等指令来进行 I/O。为支持字符串处理，RISC-V 实现了字节存取，而不是像 x86-32 那样实现了 rep，movs，coms，scas，lods 等 16 条特殊的字符串处理指令。